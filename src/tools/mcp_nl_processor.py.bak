#!/usr/bin/env python
"""
Processador de Linguagem Natural para o MCP (Module Command Processor)

Este m√≥dulo intercepta comandos em linguagem natural relacionados ao MCP
durante o chat e os traduz em a√ß√µes.
"""

import re
import json
import logging
from typing import Dict, List, Any, Optional, Tuple
import os
from pathlib import Path
import time
import webbrowser  # Importar m√≥dulo para abrir URLs no navegador
import io
import sys
from contextlib import redirect_stdout
import requests
import urllib.parse

# Importar o cliente MCP simplificado
try:
    from .mcpx_simple import MCPRunClient, configure_mcprun
    MCPRUN_SIMPLE_AVAILABLE = True
except ImportError:
    MCPRUN_SIMPLE_AVAILABLE = False

from ..providers.mcp_provider import MCPProvider

# Importar fun√ß√µes do script test_api_tess.py
try:
    from tests.test_api_tess import listar_agentes, executar_agente
    TEST_API_TESS_AVAILABLE = True
except ImportError:
    TEST_API_TESS_AVAILABLE = False

# Configurar logger
logger = logging.getLogger(__name__)

# URLs para o dashboard do TESS
TESS_DASHBOARD_URLS = {
    "transformar-texto-em-post-para-linkedin-mF37hV": "https://tess.pareto.io/pt-BR/dashboard/user/ai/generator/transformar-texto-em-post-para-linkedin-mF37hV",
    "e-mail-de-venda-Sxtjz8": "https://tess.pareto.io/pt-BR/dashboard/user/ai/generator/e-mail-de-venda-Sxtjz8",
    "titulo-de-email-para-anuncio-de-novo-recurso-fDba8a": "https://tess.pareto.io/pt-BR/dashboard/user/ai/generator/titulo-de-email-para-anuncio-de-novo-recurso-fDba8a",
    "e-mail-de-solicitacao-de-review-pos-venda-ihvlWw": "https://tess.pareto.io/pt-BR/dashboard/user/ai/generator/e-mail-de-solicitacao-de-review-pos-venda-ihvlWw",
    "palavras-chave-para-campanha-de-marca-96zlo7": "https://tess.pareto.io/pt-BR/dashboard/user/ai/generator/palavras-chave-para-campanha-de-marca-96zlo7",
    "palavras-chave-para-campanha-de-produtosservicos-egK882": "https://tess.pareto.io/pt-BR/dashboard/user/ai/generator/palavras-chave-para-campanha-de-produtosservicos-egK882"
}

def parse_tess_url(url: str) -> Tuple[Optional[str], Optional[Dict[str, Any]]]:
    """
    Analisa uma URL do TESS e extrai o slug do agente e par√¢metros.
    
    Args:
        url: URL do formato @https://tess.pareto.io/pt-BR/dashboard/user/ai/chat/ai-chat/professional-dev-ai?temperature=0&model=claude-3-7-sonnet-latest&tools=internet#
        
    Returns:
        Tupla com (slug do agente, dicion√°rio de par√¢metros)
    """
    try:
        # Remover o @ inicial se presente
        if url.startswith('@'):
            url = url[1:]
            
        # Verificar se √© uma URL v√°lida do TESS
        if not url.startswith('https://tess.pareto.io/'):
            return None, None
            
        # Extrair o slug do agente
        parsed_url = urllib.parse.urlparse(url)
        path_parts = parsed_url.path.split('/')
        
        # O slug geralmente est√° na √∫ltima parte do caminho
        slug = path_parts[-1]
        
        # Extrair par√¢metros da query string
        params = {}
        query_params = urllib.parse.parse_qs(parsed_url.query)
        
        # Converter par√¢metros de lista para valores √∫nicos
        for key, value in query_params.items():
            if value and len(value) > 0:
                params[key] = value[0]
                
        # Logger para debug
        logger.info(f"URL TESS parseada: slug={slug}, params={params}")
        
        return slug, params
    except Exception as e:
        logger.error(f"Erro ao analisar URL TESS: {e}")
        return None, None

class MCPNLProcessor:
    """
    Processador de comandos em linguagem natural para o MCP.
    
    Esta classe detecta e processa comandos em linguagem natural relacionados
    ao MCP durante o chat e executa as a√ß√µes correspondentes.
    """
    
    def __init__(self, agent=None):
        """
        Inicializa o processador de comandos do MCP.
        Define express√µes regulares para processar comandos.
        
        Args:
            agent: Agente (opcional)
        """
        # Armazenar informa√ß√µes do agente
        self.agent = agent
        
        # Flag para ativar processamento com LLM
        self.usar_llm_para_tess = False
        
        # Cache para reduzir chamadas √† API
        self.cache = {}
        self.cache_ttl = 300  # 5 minutos
        
        # Padr√µes de express√µes regulares para comandos
        self.comandos_padroes = [
            # Buscar agentes TESS por palavras-chave
            (r'(buscar?|procurar?|encontrar?|pesquisar?)\s+(agentes?|templates?|modelos?)\s+(do\s+)?(tess|tessai)(\s+com\s+|\s+sobre\s+|\s+para\s+|\s+relacionado\s+(a|com|ao)\s+|\s+de\s+)(?P<termo>[a-zA-Z0-9_\s-]+)', 'buscar_agentes'),
            
            # Buscar agentes TESS por tipo espec√≠fico
            (r'(buscar?|procurar?|encontrar?|pesquisar?)\s+(agentes?|templates?|modelos?)\s+(do\s+)?(tipo\s+)?(?P<tipo>chat|text|completion)(\s+(do|da|no|na)\s+(tess|tessai))?', 'buscar_agentes_por_tipo'),
            
            # Buscar agentes TESS por tipo espec√≠fico e termo
            (r'(buscar?|procurar?|encontrar?|pesquisar?)\s+(agentes?|templates?|modelos?)\s+(do\s+)?(tipo\s+)?(?P<tipo>chat|text|completion)(\s+(do|da|no|na)\s+(tess|tessai))?(\s+com\s+|\s+sobre\s+|\s+para\s+|\s+relacionado\s+(a|com|ao)\s+|\s+de\s+)(?P<termo>[a-zA-Z0-9_\s-]+)', 'buscar_agentes_por_tipo_e_termo'),
            
            # Novo: Listar agentes com uma palavra-chave espec√≠fica
            (r'(listar?|mostrar?|exibir?|ver?)\s+(agentes?|templates?|modelos?)\s+(com|contendo|sobre|relacionado\s+(a|com|ao))\s+(?P<keyword>[a-zA-Z0-9_\s-]+)', 'listar_agentes_por_keyword'),
            
            # Novo: Listar agentes de um tipo com uma palavra-chave espec√≠fica
            (r'(listar?|mostrar?|exibir?|ver?)\s+(agentes?|templates?|modelos?)\s+(do\s+)?(tipo\s+)?(?P<tipo>chat|text|completion)(\s+(do|da|no|na)\s+(tess|tessai))?(\s+(com|contendo|sobre|relacionado\s+(a|com|ao)))\s+(?P<keyword>[a-zA-Z0-9_\s-]+)', 'listar_agentes_por_tipo_e_keyword'),
            
            # Novo: Capturar formato simplificado "agentes <keyword>" sem palavras de liga√ß√£o
            (r'^(listar?|mostrar?|exibir?|ver?)?\s*(agentes?|templates?|modelos?)\s+(?P<keyword>[a-zA-Z0-9_\s-]{3,})$', 'listar_agentes_por_keyword'),
            
            # Novo: Comando simplificado para executar agentes (executar <id> "mensagem")
            (r'^executar\s+(?P<id>[a-zA-Z0-9_-]+)\s+[\"\'](?P<mensagem>.+)[\"\']$', 'executar_agente'),
            
            # Executar agente TESS espec√≠fico
            (r'(executar?|rodar?|usar?)\s+(o\s+)?(agente|template|modelo)\s+(do\s+)?(tess|tessai)\s+(?P<id>[a-zA-Z0-9_-]+)(\s+com\s+(mensagem|texto)\s+(?P<mensagem>[^$]+))?', 'executar_agente_tess'),
            
            # Transformar texto em post LinkedIn (comando direto)
            (r'(transformar?|converter?|criar?)\s+(esse\s+|este\s+)?(texto|conte√∫do|mensagem)\s+em\s+(post|publica√ß√£o)\s+(para|do)\s+linkedin:?\s*(?P<texto>.+)', 'transformar_post_linkedin'),
            
            # Criar email de venda (comando direto)
            (r'(criar?|gerar?|escrever?)\s+(um\s+)?(email|e-mail|mail)\s+de\s+venda\s+(para|sobre):?\s*(?P<produto>.+)', 'criar_email_venda'),
            
            # Comandos simples de ajuda
            (r'(mostrar?|ver?|listar?)\s+(comandos|op√ß√µes|ajuda)', 'mostrar_ajuda'),
            
            # Listar todos os agentes TESS
            (r'(mostrar?|exibir?|listar?|ver?)\s+(todos\s+)?(os\s+)?(agentes?|templates?|modelos?)\s+(do\s+)?(tess|tessai)', 'listar_todos_agentes'),
            
            # Listar apenas agentes de chat
            (r'(mostrar?|exibir?|listar?|ver?|filtrar?)\s+(os\s+)?agentes?\s+(do\s+)?(tipo\s+)?chat(\s+(do|da|no|na)\s+(tess|tessai))?', 'listar_agentes_chat'),
            
            # Novo: Testar API TESS para listar agentes
            (r'(testar?|usar?|executar?)\s+(a\s+)?api\s+(do\s+)?tess(\s+para)?\s+(listar|mostrar|exibir)\s+(os\s+)?(agentes?|templates?)', 'testar_api_listar_agentes'),
            
            # Novo: Testar API TESS para listar agentes do tipo chat
            (r'(testar?|usar?|executar?)\s+(a\s+)?api\s+(do\s+)?tess(\s+para)?\s+(listar|mostrar|exibir)\s+(os\s+)?agentes?\s+(do\s+)?(tipo\s+)?chat', 'testar_api_listar_agentes_chat'),
            
            # Novo: Testar API TESS para executar agente espec√≠fico
            (r'(testar?|usar?|executar?)\s+(a\s+)?api\s+(do\s+)?tess\s+(?P<id>[a-zA-Z0-9_-]+)(\s+com\s+(mensagem|texto)\s+(?P<mensagem>[^$]+))', 'testar_api_executar_agente'),
            
            # Novo: Comando abreviado para testar API
            (r'test_api_tess\s+(listar|executar)(\s+(?P<id>[a-zA-Z0-9_-]+))?(\s+(?P<mensagem>[^$]+))?', 'testar_api_tess'),
        ]
    
    def detectar_comando(self, mensagem: str) -> Tuple[bool, str, Dict[str, Any]]:
        """Detecta se uma mensagem cont√©m comandos do MCP

        Args:
            mensagem: Mensagem a ser analisada

        Returns:
            Tupla com (√©_comando, tipo_comando, parametros)
        """
        # Se o processador LLM est√° ativado, procuramos por termos relacionados ao TESS
        # e enviamos para o processamento avan√ßado com LLM se encontrarmos
        if self.usar_llm_para_tess:
            # Verificar se a mensagem cont√©m termos relacionados ao TESS
            termos_tess = ["tess", "agente", "agentes", "ferramentas", "mcp"]
            mensagem_lower = mensagem.lower()
            if any(termo in mensagem_lower for termo in termos_tess):
                # Registrar no log
                logging.info("Detectados termos relacionados ao TESS, tentando processamento com LLM")
                # Tenta processar com LLM primeiro
                tem_comando, tipo_comando, parametros = self.processar_comando_com_llm(mensagem)
                if tem_comando:
                    # Se conseguiu detectar um comando com LLM, retorna
                    return tem_comando, tipo_comando, parametros
        
        # Detectar URLs TESS
        if mensagem.startswith('@https://tess.pareto.io/'):
            logging.info("Detectada URL TESS")
            slug, params = parse_tess_url(mensagem)
            if slug:
                # Converter para o formato de comando executar_agente
                return True, "executar_agente_tess", {
                    "agent_id": slug,
                    "params": params,
                    "mensagem": "",  # Deixamos em branco pois os par√¢metros j√° v√™m da URL
                    "is_url": True
                }

        # Detecta comandos para ferramentas MCP
        # Regex para detectar comandos do tipo: "usar ferramenta X para fazer Y"
        regex_usar_ferramenta = r"(usar|executar|rodar|iniciar)\s+(?:a\s+)?(?:ferramenta\s+)?([a-zA-Z0-9_-]+)(?:\s+(?:para|com|e)\s+(.+))?$"
        match_ferramenta = re.match(regex_usar_ferramenta, mensagem, re.IGNORECASE)
        
        # Processar comando usando express√µes regulares
        for padrao, tipo_comando in self.comandos_padroes:
            match = re.search(padrao, mensagem, re.IGNORECASE)
            if match:
                # Extrair par√¢metros do comando
                params = {k: v for k, v in match.groupdict().items() if v is not None}
                logging.info(f"Detectado comando TESS via regex: {tipo_comando}")
                return True, tipo_comando, params
                
        # Se n√£o encontrou um padr√£o de regex, tentar processar com LLM
        return self.processar_comando_com_llm(mensagem)
    
    def processar_comando_com_llm(self, mensagem: str) -> Tuple[bool, str, Dict[str, Any]]:
        """
        Processa um comando usando o LLM para interpretar a inten√ß√£o do usu√°rio.
        
        Args:
            mensagem: A mensagem do usu√°rio
            
        Returns:
            Tupla (is_comando, tipo_comando, parametros)
        """
        try:
            # Verificar se a mensagem pode conter um comando TESS
            if len(mensagem.split()) < 2:  # Mensagens muito curtas provavelmente n√£o s√£o comandos
                return False, "", {}
                
            # Criar um prompt especializado para o LLM
            prompt = f"""
            Voc√™ √© um assistente especializado em interpretar comandos para o sistema TESS de agentes.
            
            Analise a seguinte mensagem do usu√°rio e determine se ela cont√©m um comando relacionado ao TESS.
            Mensagem: "{mensagem}"
            
            Se for um comando TESS, identifique qual dos seguintes tipos de comando:
            - buscar_agentes: Para buscar agentes com um termo
            - listar_agentes: Para listar todos os agentes dispon√≠veis
            - executar_agente: Para executar um agente com uma mensagem
            - obter_agente: Para obter detalhes de um agente espec√≠fico
            - buscar_arquivos: Para buscar arquivos de um agente
            
            Para o comando "executar_agente", extraia o agent_id (ou slug) e a mensagem a ser processada.
            
            Retorne a resposta no formato JSON:
            ```json
            {{"√©_comando": true/false, "tipo_comando": "tipo_do_comando", "parametros": {{"param1": "valor1", "param2": "valor2"}}}}
            ```
            
            Se for um comando "executar_agente", os par√¢metros devem ser:
            ```json
            {{"agent_id": "id_ou_slug_do_agente", "mensagem": "texto da mensagem"}}
            ```
            
            Se n√£o for um comando TESS, retorne "√©_comando" como false.
            """
            
            # Chamar o LLM do Arcee (usando generate_content_chat em vez de generate_content)
            from infrastructure.providers.arcee_provider import ArceeProvider
            provider = ArceeProvider()
            
            # Criar mensagens para o formato chat
            messages = [
                {"role": "system", "content": "Voc√™ √© um assistente especializado em interpretar comandos TESS."},
                {"role": "user", "content": prompt}
            ]
            
            # Usar generate_content_chat em vez de generate_content
            resposta = provider.generate_content_chat(messages)
            
            # Extrair o JSON da resposta
            import json
            import re
            
            # Obter o texto da resposta
            resposta_text = resposta.get('text', '')
            
            # Encontrar o bloco JSON na resposta
            json_match = re.search(r'```json\s+(.*?)\s+```', resposta_text, re.DOTALL)
            if not json_match:
                # Tentar procurar por JSON sem o marcador de c√≥digo
                json_match = re.search(r'({.*})', resposta_text, re.DOTALL)
                if not json_match:
                    return False, "", {}
                
            json_str = json_match.group(1)
            resultado = json.loads(json_str)
            
            # Verificar se √© um comando
            if not resultado.get('√©_comando', False):
                return False, "", {}
                
            # Extrair tipo e par√¢metros
            tipo_comando = resultado.get('tipo_comando', '')
            parametros = resultado.get('parametros', {})
            
            # Registrar no log
            logging.info(f"Detectado comando do TESS com LLM: {tipo_comando}")
            
            return True, tipo_comando, parametros
            
        except Exception as e:
            logging.error(f"Erro ao processar comando com LLM: {e}")
            return False, "", {}
    
    def processar_comando(self, tipo_comando: str, params: Dict[str, Any]) -> Optional[str]:
        """
        Processa um comando detectado
        
        Args:
            tipo_comando: Tipo de comando a ser processado
            params: Par√¢metros para o comando
            
        Returns:
            Resposta formatada ou None se o comando n√£o for reconhecido
        """
        # Comandos relacionados a ferramentas MCP
        if tipo_comando == "listar_ferramentas":
            return self._comando_listar_ferramentas(params)
        elif tipo_comando == "executar_ferramenta":
            return self._comando_executar_ferramenta(params)
        elif tipo_comando == "configurar_mcp":
            return self._comando_configurar_mcp(params)
            
        # Comandos relacionados ao TESS
        elif tipo_comando == "buscar_agentes":
            return self._comando_buscar_agentes(params)
        elif tipo_comando == "buscar_agentes_por_tipo":
            return self._comando_buscar_agentes_por_tipo(params)
        elif tipo_comando == "buscar_agentes_por_tipo_e_termo":
            return self._comando_buscar_agentes_por_tipo_e_termo(params)
        elif tipo_comando == "executar_agente_tess":
            # Extrair par√¢metros
            agent_id = params.get('id', '')
            mensagem = params.get('mensagem', '')
            is_url = params.get('is_url', False)
            return self._comando_executar_agente_tess(agent_id, mensagem, params, is_url)
        elif tipo_comando == "executar_agente":
            # Aqui adicionamos o handler direto para o comando executar_agente
            return self._comando_executar_agente(params)
        elif tipo_comando == "transformar_post_linkedin":
            return self._comando_transformar_post_linkedin(params)
        elif tipo_comando == "criar_email_venda":
            return self._comando_criar_email_venda(params)
        elif tipo_comando == "gerar_titulo_email":
            return self._comando_gerar_titulo_email(params)
        elif tipo_comando == "mostrar_ajuda":
            return self._comando_mostrar_ajuda(params)
        elif tipo_comando == "listar_todos_agentes":
            return self._comando_listar_todos_agentes(params)
        elif tipo_comando == "buscar_ajuda":
            return self._comando_buscar_ajuda(params)
        elif tipo_comando == "testar_api_listar_agentes":
            return self._comando_testar_api_listar_agentes(params)
        elif tipo_comando == "testar_api_executar_agente":
            return self._comando_testar_api_executar_agente(params)
        elif tipo_comando == "testar_api_tess":
            return self._comando_testar_api_tess(params)
        elif tipo_comando == "listar_agentes_chat":
            return self._comando_listar_agentes_chat(params)
        elif tipo_comando == "testar_api_listar_agentes_chat":
            return self._comando_testar_api_listar_agentes_chat(params)
        elif tipo_comando == "listar_agentes_por_keyword":
            return self._comando_listar_agentes_por_keyword(params)
        elif tipo_comando == "listar_agentes_por_tipo_e_keyword":
            return self._comando_listar_agentes_por_tipo_e_keyword(params)
        elif tipo_comando == "listar_agentes":
            # Implementar diretamente usando a fun√ß√£o do test_api_tess
            try:
                from tests.test_api_tess import listar_agentes
                success, data = listar_agentes(is_cli=False)
                if not success:
                    return f"‚ùå Erro ao listar agentes: {data.get('error', 'Erro desconhecido')}"
                
                # Formatar a resposta para exibi√ß√£o
                total_agentes = len(data.get('data', []))
                resposta = f"üìã Lista de agentes dispon√≠veis (Total: {total_agentes}):\n\n"
                
                for i, agente in enumerate(data.get('data', []), 1):
                    # Obter o tipo do agente (chat, text, etc)
                    tipo_agente = agente.get('type', 'desconhecido')
                    tipo_icone = "üí¨" if tipo_agente == "chat" else "üìù" if tipo_agente == "text" else "üîÑ"
                    
                    resposta += f"{i}. {agente.get('title', 'Sem t√≠tulo')} {tipo_icone}\n"
                    resposta += f"   ID: {agente.get('id', 'N/A')}\n"
                    resposta += f"   Slug: {agente.get('slug', 'N/A')}\n"
                    resposta += f"   Tipo: {tipo_agente.capitalize()}\n"
                    resposta += f"   Descri√ß√£o: {agente.get('description', 'Sem descri√ß√£o')}\n\n"
                
                resposta += "Para executar um agente, use: executar agente <slug> \"sua mensagem aqui\""
                
                return resposta
            except Exception as e:
                logging.error(f"Erro ao listar agentes TESS: {e}")
                return f"‚ùå Erro ao listar agentes: {str(e)}"
            
        logging.warning(f"Comando n√£o implementado: {tipo_comando}")
        return f"Comando n√£o implementado: {tipo_comando}"
    
    def _comando_listar_ferramentas(self, params: Dict[str, Any]) -> str:
        """
        Lista as ferramentas dispon√≠veis no MCP
        """
        # Verificar se o MCP est√° configurado
        session_id = MCPProvider.get_mcp_session_id()
        if not session_id:
            return "‚ùå MCP n√£o configurado. Use 'configurar mcp' primeiro."
        
        try:
            # Criar cliente MCP
            client = MCPRunClient(session_id=session_id)
            
            # Obter ferramentas
            tools = client.get_tools()
            
            if not tools:
                return "‚ÑπÔ∏è Nenhuma ferramenta MCP dispon√≠vel para esta sess√£o."
            
            # Formatar resposta
            resultado = "üìã **Ferramentas MCP dispon√≠veis:**\n\n"
            
            for i, tool in enumerate(tools, 1):
                nome = tool.get('name', 'N/A')
                descricao = tool.get('description', 'Sem descri√ß√£o')
                resultado += f"{i}. **{nome}**\n"
                resultado += f"   {descricao}\n\n"
            
            return resultado.strip()
            
        except Exception as e:
            logger.exception(f"Erro ao listar ferramentas MCP: {e}")
            return f"‚ùå Erro ao listar ferramentas: {str(e)}"
    
    def _comando_configurar_mcp(self, params: Dict[str, Any]) -> str:
        """
        Configura o MCP com um ID de sess√£o
        """
        session_id = params.get('session_id')
        
        try:
            # Configurar MCP
            new_session_id = configure_mcprun(session_id)
            
            if new_session_id:
                # Salvar ID de sess√£o
                if MCPProvider.save_mcp_session_id(new_session_id):
                    return f"‚úÖ MCP configurado com sucesso!\nID de sess√£o: {new_session_id}"
                else:
                    return f"‚ö†Ô∏è MCP configurado, mas n√£o foi poss√≠vel salvar o ID de sess√£o.\nID de sess√£o atual: {new_session_id}"
            else:
                return "‚ùå N√£o foi poss√≠vel configurar o MCP.\nVerifique os logs para mais detalhes."
                
        except Exception as e:
            logger.exception(f"Erro ao configurar MCP: {e}")
            return f"‚ùå Erro ao configurar MCP: {str(e)}"
    
    def _comando_executar_ferramenta(self, params: Dict[str, Any]) -> str:
        """
        Executa uma ferramenta MCP
        """
        # Obter nome da ferramenta
        nome = params.get('nome')
        if not nome:
            return "‚ùå Nome da ferramenta n√£o especificado."
        
        # Obter par√¢metros (se fornecidos)
        tool_params = params.get('params', {})
        
        # Verificar se o MCP est√° configurado
        session_id = MCPProvider.get_mcp_session_id()
        if not session_id:
            return "‚ùå MCP n√£o configurado. Use 'configurar mcp' primeiro."
        
        try:
            # Criar cliente MCP
            client = MCPRunClient(session_id=session_id)
            
            # Executar ferramenta
            result = client.run_tool(nome, tool_params)
            
            # Verificar se houve erro
            if result.get('error'):
                return f"‚ùå Erro ao executar ferramenta: {result['error']}"
            
            # Formatar resposta
            return f"‚úÖ **Resultado da ferramenta {nome}:**\n\n```json\n{json.dumps(result, indent=2, ensure_ascii=False)}\n```"
            
        except Exception as e:
            logger.exception(f"Erro ao executar ferramenta MCP: {e}")
            return f"‚ùå Erro ao executar ferramenta: {str(e)}"
            
    def _comando_buscar_agentes(self, params: Dict[str, Any]) -> str:
        """
        Busca agentes TESS por termo
        
        Args:
            params: Par√¢metros com termo de busca e opcionalmente um tipo
            
        Returns:
            Resposta formatada com os agentes encontrados
        """
        # Obter termo de busca
        termo = params.get('termo', '').strip()
        tipo = params.get('tipo', '').strip().lower()
        
        if not termo and not tipo:
            return "‚ùå Por favor, especifique um termo para buscar agentes TESS ou um tipo espec√≠fico (chat, text, etc.)."
        
        # Definir mapeamento de slugs para IDs (baseado no test_api_tess.py)
        slug_para_id = {
            "e-mail-de-venda-Sxtjz8": "53",
            "titulo-de-email-para-anuncio-de-novo-recurso-fDba8a": "52",
            "e-mail-de-solicitacao-de-review-pos-venda-ihvlWw": "55",
            "palavras-chave-para-campanha-de-marca-96zlo7": "59",
            "palavras-chave-para-campanha-de-produtosservicos-egK882": "60",
            "transformar-texto-em-post-para-linkedin-mF37hV": "67"
        }
        
        # Implementar a consulta √† API TESS
        try:
            # Obter a chave de API do ambiente
            api_key = os.getenv("TESS_API_KEY")
            if not api_key:
                return "‚ùå ERRO: Chave API do TESS n√£o encontrada nas vari√°veis de ambiente. Configure a vari√°vel TESS_API_KEY."
            
            # Configura√ß√£o da requisi√ß√£o
            url = 'https://tess.pareto.io/api/agents'
            headers = {
                'Authorization': f'Bearer {api_key}',
                'Content-Type': 'application/json'
            }
            
            # Par√¢metros de pagina√ß√£o
            request_params = {
                'page': 1,
                'per_page': 50  # Aumentamos para ter mais resultados
            }
            
            # Adicionar tipo ao par√¢metro se especificado
            if tipo:
                request_params['type'] = tipo
                logging.info(f'Realizando requisi√ß√£o para buscar agentes TESS do tipo {tipo} com termo: {termo}...')
            else:
                logging.info(f'Realizando requisi√ß√£o para buscar agentes TESS com termo: {termo}...')
            
            # Fazer a requisi√ß√£o
            response = requests.get(url, headers=headers, params=request_params, timeout=30)
            response.raise_for_status()  # Levanta exce√ß√£o para erros HTTP
            
            # Processar a resposta
            data = response.json()
            agentes = data.get('data', [])
            
            # Filtragem adicional de tipo - caso a API n√£o suporte filtro por tipo no par√¢metro
            if tipo and 'type' not in request_params:
                agentes_filtrados = [a for a in agentes if a.get('type', '').lower() == tipo]
                
                # Se encontrou agentes com o tipo, substitui a lista
                if agentes_filtrados:
                    agentes = agentes_filtrados
                    logging.info(f"Filtro adicional por tipo '{tipo}' aplicado: {len(agentes)} agentes")
            
            # Filtrar agentes que correspondem ao termo de busca (se houver termo)
            resultados = []
            if termo:
                for agente in agentes:
                    titulo = agente.get('title', '').lower()
                    descricao = agente.get('description', '').lower()
                    
                    if termo.lower() in titulo or termo.lower() in descricao:
                        resultados.append(agente)
            else:
                # Se n√£o h√° termo de busca, usar todos os agentes j√° filtrados por tipo
                resultados = agentes
            
            # Formatar a resposta
            if not resultados:
                mensagem_erro = ""
                if termo and tipo:
                    mensagem_erro = f"üîç Nenhum agente do tipo '{tipo}' encontrado para o termo de busca: \"{termo}\""
                elif tipo:
                    mensagem_erro = f"üîç Nenhum agente do tipo '{tipo}' encontrado"
                else:
                    mensagem_erro = f"üîç Nenhum agente encontrado para o termo de busca: \"{termo}\""
                return mensagem_erro
            
            # Texto do cabe√ßalho com base no filtro
            if termo and tipo:
                resposta = f"üîç Encontrados {len(resultados)} agentes do tipo '{tipo}' para o termo \"{termo}\":\n\n"
            elif tipo:
                resposta = f"üîç Encontrados {len(resultados)} agentes do tipo '{tipo}':\n\n"
            else:
                resposta = f"üîç Encontrados {len(resultados)} agentes para o termo \"{termo}\":\n\n"
            
            for i, agente in enumerate(resultados, 1):
                # Obter o tipo do agente (chat, text, etc)
                tipo_agente = agente.get('type', 'desconhecido')
                tipo_icone = "üí¨" if tipo_agente == "chat" else "üìù" if tipo_agente == "text" else "üîÑ"
                
                resposta += f"{i}. {agente.get('title', 'Sem t√≠tulo')} {tipo_icone}\n"
                resposta += f"   ID: {agente.get('id', 'N/A')}\n"
                resposta += f"   Slug: {agente.get('slug', 'N/A')}\n"
                resposta += f"   Tipo: {tipo_agente.capitalize()}\n"
                resposta += f"   Descri√ß√£o: {agente.get('description', 'Sem descri√ß√£o')}\n\n"
            
            resposta += "Para executar um agente, use: executar agente <slug> \"sua mensagem aqui\""
            
            return resposta
            
        except requests.exceptions.RequestException as e:
            logging.error(f"Erro ao buscar agentes TESS: {e}")
            return f"‚ùå Erro ao buscar agentes: {str(e)}"
    
    def _comando_buscar_agentes_por_tipo(self, params: Dict[str, Any]) -> str:
        """
        Busca agentes TESS por tipo espec√≠fico
        
        Args:
            params: Par√¢metros com tipo de agente
            
        Returns:
            Resposta formatada com os agentes encontrados
        """
        # Extrair o tipo do par√¢metro
        tipo = params.get('tipo', '').strip().lower()
        if not tipo:
            return "‚ùå Por favor, especifique o tipo de agente (chat, text, etc)."
            
        # Chamar o m√©todo de busca com o tipo apenas
        return self._comando_buscar_agentes({'tipo': tipo})
    
    def _comando_buscar_agentes_por_tipo_e_termo(self, params: Dict[str, Any]) -> str:
        """
        Busca agentes TESS por tipo e termo
        
        Args:
            params: Par√¢metros com tipo de agente e termo de busca
            
        Returns:
            Resposta formatada com os agentes encontrados
        """
        # Extrair o tipo e o termo dos par√¢metros
        tipo = params.get('tipo', '').strip().lower()
        termo = params.get('termo', '').strip()
        
        if not tipo:
            return "‚ùå Por favor, especifique o tipo de agente (chat, text, etc)."
            
        if not termo:
            return "‚ùå Por favor, especifique um termo para buscar agentes do tipo especificado."
            
        # Chamar o m√©todo de busca com tipo e termo
        return self._comando_buscar_agentes({'tipo': tipo, 'termo': termo})
    
    def _comando_executar_agente_tess(self, agent_id, mensagem, params, is_url=False):
        """
        Executa um agente TESS com o ID e a mensagem especificados
        
        Args:
            agent_id: ID ou slug do agente
            mensagem: Mensagem a ser processada
            params: Par√¢metros adicionais do agente
            is_url: Se a execu√ß√£o foi iniciada a partir de uma URL
            
        Returns:
            Resposta formatada com a sa√≠da do agente
        """
        # Verificar se o m√≥dulo test_api_tess est√° dispon√≠vel
        if not TEST_API_TESS_AVAILABLE:
            return "‚ùå M√≥dulo test_api_tess n√£o est√° dispon√≠vel. Verifique se o arquivo est√° no diret√≥rio 'tests'."
        
        # Verificar se os par√¢metros foram fornecidos
        if not agent_id or agent_id.strip() == "":
            return "‚ùå Por favor, especifique o ID ou slug do agente."
        
        if not mensagem and not is_url:
            return f"‚ùå Por favor, forne√ßa uma mensagem para o agente '{agent_id}'."
            
        # Usar mensagem padr√£o gen√©rica para URLs se n√£o tiver sido especificada
        if is_url and not mensagem:
            mensagem = "Ol√°, como posso ajudar?"
        
        agent_id = agent_id.strip()
        mensagem = mensagem.strip()
        
        # Remover quaisquer caracteres extras (como aspas) que possam ter vindo da entrada
        agent_id = agent_id.strip('"\'`')
        
        logger.info(f"Executando agente TESS (ID: {agent_id}) com mensagem: {mensagem[:50]}...")
        
        # Par√¢metros espec√≠ficos para cada agente
        specific_params = None
        
        # Para URLs, temos par√¢metros espec√≠ficos do modelo na URL
        if is_url and isinstance(params, dict):
            # Extrair modelo, ferramentas e temperatura da URL
            modelo = params.get("model", "tess-5-pro")
            temperatura = params.get("temperature", "0.5")
            ferramentas = params.get("tools", "no-tools")
            
            # Criar estrutura espec√≠fica para agentes de chat
            specific_params = {
                "temperature": temperatura,
                "model": modelo,
                "tools": ferramentas,
                "messages": [
                    {"role": "user", "content": mensagem}
                ],
                "waitExecution": True
            }
            
            logger.info(f"Executando agente TESS a partir de URL com par√¢metros: {specific_params}")
        
        try:
            # Executar o agente
            if specific_params:
                success, response = executar_agente(agent_id, mensagem, is_cli=False, specific_params=specific_params)
            else:
                success, response = executar_agente(agent_id, mensagem, is_cli=False)
            
            if success:
                # Verificar se h√° output direto
                if "output" in response:
                    output_text = response["output"]
                    return f"‚úÖ **Resposta do agente TESS ({agent_id}):**\n\n{output_text}"
                # Verificar se h√° resultado parcial
                elif "partial_result" in response:
                    partial = response["partial_result"]
                    if 'responses' in partial and len(partial['responses']) > 0:
                        response_data = partial['responses'][0]
                        status = response_data.get('status', 'desconhecido')
                        
                        # Se o status for 'failed', recuperar a mensagem de erro
                        if status == 'failed':
                            error_info = response_data.get('error', {})
                            error_message = error_info.get('message', 'Erro desconhecido')
                            return f"‚ùå Falha na execu√ß√£o do agente: {error_message}"
                        
                        # Se for 'succeeded' mas n√£o temos output ainda
                        if status == 'succeeded':
                            output = response_data.get('output', 'Sem sa√≠da dispon√≠vel')
                            return f"‚úÖ **Resposta do agente TESS ({agent_id}):**\n\n{output}"
                        
                        return f"‚è≥ Execu√ß√£o do agente em andamento. Status: {status}"
                    
                    return "‚è≥ Execu√ß√£o do agente iniciada. Aguarde o processamento."
                # Verificar se h√° full_response
                elif "full_response" in response and isinstance(response["full_response"], dict):
                    output = response["full_response"].get("output", "")
                    if output:
                        return f"‚úÖ **Resposta do agente TESS ({agent_id}):**\n\n{output}"
            
            # Se n√£o encontrou output em nenhum dos formatos esperados
            error_msg = response.get("error", "Erro desconhecido")
            error_details = response.get("details", {})
            
            # Verificar se temos detalhes espec√≠ficos do erro
            if isinstance(error_details, dict):
                if "status" in error_details and error_details["status"] == 422:
                    error_text = error_details.get("text", "")
                    try:
                        error_json = json.loads(error_text)
                        if "message" in error_json:
                            error_message = error_json["message"]
                            error_fields = error_json.get("errors", {})
                            
                            # Listar campos obrigat√≥rios faltantes
                            missing_fields = []
                            for field, msgs in error_fields.items():
                                if msgs and "required" in msgs[0]:
                                    missing_fields.append(field)
                            
                            if missing_fields:
                                return (f"‚ùå Erro 422: O agente '{agent_id}' exige campos obrigat√≥rios que n√£o foram fornecidos:\n"
                                       f"{', '.join(missing_fields)}\n"
                                       f"Por favor, forne√ßa esses campos ou use um agente diferente.")
                            
                            return f"‚ùå Erro ao executar agente: {error_message}"
                    except:
                        pass
                
                return (f"‚ùå Erro 422: O agente '{agent_id}' rejeitou a requisi√ß√£o, provavelmente "
                       f"porque faltam par√¢metros obrigat√≥rios ou o formato est√° incorreto.\n"
                       f"Tente usar um agente diferente ou verificar a documenta√ß√£o do agente.")
            
            return f"‚ùå Erro ao executar agente: {error_msg}"
        except Exception as e:
            logger.exception(f"Erro ao executar agente: {e}")
            return f"‚ùå Erro ao executar agente: {str(e)}"
    
    def _comando_transformar_post_linkedin(self, params: Dict[str, Any]) -> str:
        """
        Transforma um texto em um post para LinkedIn usando o agente TESS espec√≠fico
        Tamb√©m oferece a op√ß√£o de abrir a interface web do TESS
        
        Args:
            params: Par√¢metros com o texto a ser transformado
            
        Returns:
            Resposta formatada com o post gerado e op√ß√£o de interface web
        """
        # Verificar se temos o texto
        texto = params.get('texto', '').strip()
        if not texto:
            return "‚ùå Por favor, forne√ßa o texto que deseja transformar em post para LinkedIn. Exemplo: 'Transformar em post para LinkedIn: Lan√ßamos nosso novo produto de IA hoje.'"
        
        # ID do agente
        agent_id = 'transformar-texto-em-post-para-linkedin-mF37hV'
        
        # Oferecer a op√ß√£o de usar a interface web
        dashboard_url = TESS_DASHBOARD_URLS.get(agent_id)
        web_option = ""
        if dashboard_url:
            web_option = f"\n\nüíª **Prefere usar a interface web?**\nDigite 'abrir tess linkedin' para acessar o gerador diretamente no navegador."
            
            # Se o comando espec√≠fico para abrir a web for detectado
            if params.get('open_web'):
                try:
                    webbrowser.open(dashboard_url)
                    return f"‚úÖ Abrindo interface web do TESS para transformar texto em post LinkedIn...\nURL: {dashboard_url}"
                except Exception as e:
                    logger.exception(f"Erro ao abrir navegador: {e}")
                    return f"‚ùå N√£o foi poss√≠vel abrir o navegador. URL: {dashboard_url}"
        
        # Se n√£o solicitou para abrir a web, executa o agente
        resultado = self._comando_executar_agente_tess(agent_id, texto, params, params.get('is_url', False))
        
        # Adicionar op√ß√£o de interface web √† resposta
        if resultado and web_option:
            resultado += web_option
            
        return resultado
    
    def _comando_criar_email_venda(self, params: Dict[str, Any]) -> str:
        """
        Cria um email de venda usando o agente TESS espec√≠fico
        Tamb√©m oferece a op√ß√£o de abrir a interface web do TESS
        
        Args:
            params: Par√¢metros com o produto/servi√ßo
            
        Returns:
            Resposta formatada com o email gerado e op√ß√£o de interface web
        """
        # Verificar se temos o produto/servi√ßo
        produto = params.get('produto', '').strip()
        if not produto:
            return "‚ùå Por favor, especifique o produto ou servi√ßo para o email de venda. Exemplo: 'Criar email de venda para: Software de automa√ß√£o de marketing'"
        
        # ID do agente
        agent_id = 'e-mail-de-venda-Sxtjz8'
        
        # Oferecer a op√ß√£o de usar a interface web
        dashboard_url = TESS_DASHBOARD_URLS.get(agent_id)
        web_option = ""
        if dashboard_url:
            web_option = f"\n\nüíª **Prefere usar a interface web?**\nDigite 'abrir tess email' para acessar o gerador de email diretamente no navegador."
            
            # Se o comando espec√≠fico para abrir a web for detectado
            if params.get('open_web'):
                try:
                    webbrowser.open(dashboard_url)
                    return f"‚úÖ Abrindo interface web do TESS para criar email de venda...\nURL: {dashboard_url}"
                except Exception as e:
                    logger.exception(f"Erro ao abrir navegador: {e}")
                    return f"‚ùå N√£o foi poss√≠vel abrir o navegador. URL: {dashboard_url}"
        
        # Se n√£o solicitou para abrir a web, executa o agente
        resultado = self._comando_executar_agente_tess(agent_id, produto, params, params.get('is_url', False))
        
        # Adicionar op√ß√£o de interface web √† resposta
        if resultado and web_option:
            resultado += web_option
            
        return resultado
    
    def _comando_gerar_titulo_email(self, params: Dict[str, Any]) -> str:
        """
        Gera um t√≠tulo de email para an√∫ncio de novo recurso
        
        Args:
            params: Par√¢metros com o recurso anunciado
            
        Returns:
            Resposta formatada com o t√≠tulo gerado
        """
        # Verificar se temos o recurso
        recurso = params.get('recurso', '').strip()
        if not recurso:
            return "‚ùå Por favor, especifique o recurso ou produto para o t√≠tulo do email. Exemplo: 'Gerar t√≠tulo de email para an√∫ncio: Nova interface do usu√°rio'"
        
        # Prepara par√¢metros para executar o agente apropriado
        return self._comando_executar_agente_tess('titulo-de-email-para-anuncio-de-novo-recurso-fDba8a', recurso, params, params.get('is_url', False))
    
    def _comando_mostrar_ajuda(self, params: Dict[str, Any]) -> str:
        """
        Mostra ajuda sobre os comandos dispon√≠veis
        
        Args:
            params: Par√¢metros (n√£o utilizados)
            
        Returns:
            Mensagem de ajuda formatada
        """
        ajuda = """# Comandos TESS AI dispon√≠veis

## Agentes e Templates
- **buscar agentes tess para <termo>** - Busca agentes por tema (email, linkedin, etc.)
- **buscar agentes tipo chat** - Busca agentes do tipo chat
- **buscar agentes tipo chat para <termo>** - Busca agentes do tipo chat com filtro adicional
- **listar agentes do tess** - Mostra todos os agentes dispon√≠veis
- **listar agentes chat** - Mostra apenas os agentes do tipo chat
- **executar agente tess <id> com mensagem <texto>** - Executa um agente espec√≠fico

## Comandos diretos
- **transformar texto em post para linkedin: <texto>** - Cria um post otimizado para LinkedIn
- **criar email de venda para: <produto>** - Gera um email persuasivo de vendas

## Interface Web
- **abrir tess linkedin** - Abre a interface web do TESS para criar posts do LinkedIn
- **abrir tess email** - Abre a interface web do TESS para criar emails de venda

## Testes API TESS
- **testar api tess para listar agentes** - Lista todos os agentes via API direta
- **testar api tess para listar agentes chat** - Lista agentes de chat via API direta
- **testar api tess <id> com mensagem <texto>** - Executa um agente espec√≠fico via API direta
- **test_api_tess listar** - Vers√£o abreviada para listar agentes
- **test_api_tess chat** - Vers√£o abreviada para listar agentes chat
- **test_api_tess executar <id> <mensagem>** - Vers√£o abreviada para executar agente

Use linguagem natural para interagir com os comandos. Experimente!"""
        
        return ajuda
    
    def _comando_listar_todos_agentes(self, params: Dict[str, Any]) -> str:
        """
        Lista todos os agentes dispon√≠veis na TESS, com op√ß√£o de filtrar por tipo
        
        Args:
            params: Par√¢metros com filtro de tipo (opcional)
            
        Returns:
            Resposta formatada com os agentes
        """
        try:
            # Verificar se h√° filtro de tipo
            tipo_filtro = params.get('tipo', '').strip().lower()
            
            # Obter a chave de API do ambiente
            api_key = os.getenv("TESS_API_KEY")
            if not api_key:
                return "‚ùå ERRO: Chave API do TESS n√£o encontrada nas vari√°veis de ambiente. Configure a vari√°vel TESS_API_KEY."
            
            # Configura√ß√£o da requisi√ß√£o
            url = 'https://tess.pareto.io/api/agents'
            headers = {
                'Authorization': f'Bearer {api_key}',
                'Content-Type': 'application/json'
            }
            
            # Par√¢metros de pagina√ß√£o e filtro
            request_params = {
                'page': 1,
                'per_page': 30  # Aumentamos para ter mais resultados
            }
            
            # Adicionar filtro de tipo na requisi√ß√£o, se fornecido
            if tipo_filtro:
                request_params['type'] = tipo_filtro
                logging.info(f'Realizando requisi√ß√£o para listar agentes TESS com filtro de tipo: {tipo_filtro}...')
            else:
                logging.info('Realizando requisi√ß√£o para listar todos os agentes TESS...')
            
            # Fazer a requisi√ß√£o
            response = requests.get(url, headers=headers, params=request_params, timeout=30)
            response.raise_for_status()  # Levanta exce√ß√£o para erros HTTP
            
            # Processar a resposta
            data = response.json()
            agentes = data.get('data', [])
            total = data.get('total', 0)
            
            # Filtrar localmente pelo tipo, se filtro n√£o foi aplicado na requisi√ß√£o
            if tipo_filtro and 'type' not in request_params:
                agentes = [a for a in agentes if a.get('type', '').lower() == tipo_filtro]
                total = len(agentes)
            
            # Formatar a resposta
            if not agentes:
                if tipo_filtro:
                    return f"üîç Nenhum agente do tipo '{tipo_filtro}' dispon√≠vel no momento."
                else:
                    return "üîç Nenhum agente dispon√≠vel no momento."
            
            # Texto do cabe√ßalho com base no filtro
            if tipo_filtro:
                resposta = f"üìã Lista de agentes do tipo '{tipo_filtro}' (Total: {total}):\n\n"
            else:
                resposta = f"üìã Lista de agentes dispon√≠veis (Total: {total}):\n\n"
            
            for i, agente in enumerate(agentes, 1):
                # Obter o tipo do agente (chat, text, etc)
                tipo_agente = agente.get('type', 'desconhecido')
                tipo_icone = "üí¨" if tipo_agente == "chat" else "üìù" if tipo_agente == "text" else "üîÑ"
                
                resposta += f"{i}. {agente.get('title', 'Sem t√≠tulo')} {tipo_icone}\n"
                resposta += f"   ID: {agente.get('id', 'N/A')}\n"
                resposta += f"   Slug: {agente.get('slug', 'N/A')}\n"
                resposta += f"   Tipo: {tipo_agente.capitalize()}\n"
                resposta += f"   Descri√ß√£o: {agente.get('description', 'Sem descri√ß√£o')}\n\n"
            
            resposta += "Para executar um agente, use: executar agente <slug> \"sua mensagem aqui\""
            
            return resposta
            
        except requests.exceptions.RequestException as e:
            logging.error(f"Erro ao listar agentes TESS: {e}")
            return f"‚ùå Erro ao listar agentes: {str(e)}"
    
    def _comando_buscar_ajuda(self, params: Dict[str, Any]) -> str:
        """
        Responde a perguntas sobre como fazer algo com o TESS
        
        Args:
            params: Par√¢metros com a√ß√£o desejada
            
        Returns:
            Resposta com instru√ß√µes
        """
        acao = params.get('acao', '').lower()
        
        # Mapear a√ß√µes comuns para respostas espec√≠ficas
        if 'post' in acao or 'linkedin' in acao:
            return "Para criar um post para LinkedIn, voc√™ pode usar:\n\n'transformar texto em post para linkedin: seu texto aqui'\n\nOu ent√£o: 'executar agente tess transformar-texto-em-post-para-linkedin-mF37hV com mensagem seu texto aqui'"
        
        elif 'email' in acao or 'e-mail' in acao or 'venda' in acao:
            return "Para criar um email de vendas, voc√™ pode usar:\n\n'criar email de venda para: nome do seu produto/servi√ßo'\n\nOu ent√£o: 'executar agente tess e-mail-de-venda-Sxtjz8 com mensagem descri√ß√£o do seu produto/servi√ßo'"
        
        elif 't√≠tulo' in acao or 'assunto' in acao or 'an√∫ncio' in acao:
            return "Para criar um t√≠tulo ou assunto de email para an√∫ncio, voc√™ pode usar:\n\n'gerar t√≠tulo de email para an√∫ncio: nome do recurso ou produto'\n\nOu ent√£o: 'executar agente tess titulo-de-email-para-anuncio-de-novo-recurso-fDba8a com mensagem nome do recurso'"
        
        elif 'agentes' in acao or 'modelos' in acao or 'templates' in acao:
            return "Para ver todos os agentes dispon√≠veis, digite:\n\n'listar agentes do tess'\n\nPara buscar agentes sobre um tema espec√≠fico:\n'buscar agentes tess para: tema de interesse'"
        
        # Resposta gen√©rica
        return "Se voc√™ quer utilizar o TESS, veja as op√ß√µes dispon√≠veis com 'mostrar comandos' ou tente um destes formatos:\n\n1. 'transformar texto em post para linkedin: seu texto'\n2. 'criar email de venda para: seu produto'\n3. 'buscar agentes tess para: tema de interesse'"
    
    # Novos m√©todos para testar a API TESS
    
    def _comando_testar_api_listar_agentes(self, params: Dict[str, Any]) -> str:
        """
        Testa a API do TESS para listar todos os agentes
        
        Args:
            params: Par√¢metros (opcional - pode conter filtros)
            
        Returns:
            Resposta formatada com a lista de agentes
        """
        from tests.test_api_tess import listar_agentes
        
        # Verificar se h√° filtro de tipo nos par√¢metros
        filter_type = params.get('tipo') if params else None
        
        # Chamar a fun√ß√£o importada com par√¢metro is_cli=False para retornar os dados
        sucesso, dados = listar_agentes(is_cli=False, filter_type=filter_type)
        
        if not sucesso:
            return f"‚ùå Erro ao testar API TESS: {dados.get('error', 'Erro desconhecido')}"
        
        # Formatar a resposta para exibi√ß√£o
        total_agentes = len(dados.get('data', []))
        tipo_msg = f" do tipo '{filter_type}'" if filter_type else ""
        resposta = [f"‚úÖ API do TESS testada com sucesso! Total de agentes{tipo_msg}: {total_agentes}\n"]
        
        # Adicionar informa√ß√µes de cada agente
        for i, agente in enumerate(dados.get('data', []), 1):
            resposta.append(f"{i}. {agente.get('title', 'Sem t√≠tulo')}")
            resposta.append(f"   ID: {agente.get('id', 'N/A')}")
            resposta.append(f"   Slug: {agente.get('slug', 'N/A')}")
            resposta.append(f"   Tipo: {agente.get('type', 'N/A')}")
            resposta.append("")
        
        return "\n".join(resposta)
        
    def _comando_testar_api_executar_agente(self, params: Dict[str, Any]) -> str:
        """
        Testa a API do TESS para executar um agente espec√≠fico
        
        Args:
            params: Par√¢metros com ID do agente e mensagem
            
        Returns:
            Resposta formatada com o resultado da execu√ß√£o
        """
        # Obter ID do agente
        agente_id = params.get('id', '').strip()
        if not agente_id:
            return "‚ùå Por favor, especifique o ID do agente TESS para testar."
        
        # Obter mensagem
        mensagem = params.get('mensagem', '').strip()
        if not mensagem:
            return f"‚ùå Por favor, forne√ßa uma mensagem para testar o agente '{agente_id}'."
        
        try:
            # Capturar a sa√≠da da fun√ß√£o executar_agente
            old_stdout = sys.stdout
            new_stdout = io.StringIO()
            
            with redirect_stdout(new_stdout):
                success = executar_agente(agente_id, mensagem)
            
            output = new_stdout.getvalue()
            
            # Formatar a resposta para o chat
            if success:
                # Extrair o resultado da execu√ß√£o
                linhas = output.split('\n')
                resposta = f"‚úÖ **Resultado da API TESS (executar agente {agente_id}):**\n\n"
                
                # Procurar pela resposta do agente
                found_response = False
                response_text = ""
                
                for i, linha in enumerate(linhas):
                    if 'Resposta do agente:' in linha and i+1 < len(linhas):
                        found_response = True
                        continue
                    
                    if found_response and not linha.startswith('Detalhes completos:'):
                        response_text += linha + "\n"
                    
                    if 'Detalhes completos:' in linha:
                        found_response = False
                
                if response_text:
                    resposta += response_text
                else:
                    resposta += f"A API foi executada com sucesso, mas n√£o foi poss√≠vel extrair a resposta do agente.\n\n```\n{output[:500]}...\n```"
                
                return resposta
            else:
                return f"‚ùå Falha ao executar agente via API TESS.\n\n```\n{output[:500]}...\n```"
                
        except Exception as e:
            logger.exception(f"Erro ao testar API TESS (executar agente): {e}")
            return f"‚ùå Erro ao testar API TESS: {str(e)}"
    
    def _comando_testar_api_tess(self, params: Dict[str, Any]) -> str:
        """
        Comando abreviado para testar API do TESS (listar ou executar)
        
        Args:
            params: Par√¢metros com subcamando e poss√≠veis argumentos
            
        Returns:
            Resultado do comando executado
        """
        # Verificar qual subcomando deve ser processado
        subcomando = params.get('id') if 'id' in params else None
        
        if not subcomando:
            # Se n√£o tiver subcomando, verificar outros par√¢metros
            for palavra in ['listar', 'executar', 'chat']:
                if palavra in str(params):
                    subcomando = palavra
                    break
        
        # Processar o subcomando
        if subcomando == 'listar':
            return self._comando_testar_api_listar_agentes({})
        elif subcomando == 'chat':
            return self._comando_testar_api_listar_agentes_chat({})
        elif subcomando in ['executar', 'exec'] and 'mensagem' in params:
            # Extrair ID do agente do primeiro par√¢metro
            agente_id = params.get('id', '').split()[0] if params.get('id') else ''
            # Extrair mensagem do segundo par√¢metro
            mensagem = params.get('mensagem', '')
            
            if not agente_id or not mensagem:
                return "‚ùå Comando incompleto: Forne√ßa o ID do agente e a mensagem"
                
            return self._comando_testar_api_executar_agente({
                'id': agente_id,
                'mensagem': mensagem
            })
        else:
            return """‚ö†Ô∏è Comando test_api_tess requer um subcomando v√°lido:
- test_api_tess listar = Lista todos os agentes
- test_api_tess chat = Lista agentes do tipo chat
- test_api_tess executar {ID} {MENSAGEM} = Executa um agente espec√≠fico"""

    def _comando_executar_agente(self, params: Dict[str, Any]) -> str:
        """
        Executa um agente TESS com um ID e uma mensagem
        
        Args:
            params: Dicion√°rio com 'id' e 'mensagem'
            
        Returns:
            Resposta formatada com a sa√≠da do agente
        """
        # Verificar se o m√≥dulo test_api_tess est√° dispon√≠vel
        if not TEST_API_TESS_AVAILABLE:
            return "‚ùå M√≥dulo test_api_tess n√£o est√° dispon√≠vel. Verifique se o arquivo est√° no diret√≥rio 'tests'."
        
        # Obter agente_id e mensagem dos par√¢metros
        agent_id = params.get('id', '').strip()
        if not agent_id:
            return "‚ùå Por favor, especifique o ID ou slug do agente."
        
        mensagem = params.get('mensagem', '').strip()
        if not mensagem:
            return f"‚ùå Por favor, forne√ßa uma mensagem para o agente '{agent_id}'."
        
        # Remover caracteres extras que possam ter vindo do LLM (como aspas)
        agent_id = agent_id.strip('"\'`')
        mensagem = mensagem.strip('"\'`')
        
        logger.info(f"Executando agente TESS (ID: {agent_id}) com mensagem: {mensagem[:50]}...")
        
        try:
            # Usar a fun√ß√£o executar_agente do m√≥dulo test_api_tess com consulta din√¢mica
            success, response = executar_agente(agent_id, mensagem, is_cli=False)
            
            if success:
                # Verificar se h√° output direto
                if "output" in response:
                    output_text = response["output"]
                    return f"‚úÖ **Resposta do agente TESS ({agent_id}):**\n\n{output_text}"
                # Verificar se h√° resultado parcial
                elif "partial_result" in response:
                    partial = response["partial_result"]
                    if 'responses' in partial and len(partial['responses']) > 0:
                        response_data = partial['responses'][0]
                        status = response_data.get('status', 'desconhecido')
                        
                        # Se o status for 'failed', recuperar a mensagem de erro
                        if status == 'failed':
                            error_info = response_data.get('error', {})
                            error_message = error_info.get('message', 'Erro desconhecido')
                            return f"‚ùå Falha na execu√ß√£o do agente: {error_message}"
                        
                        # Se for 'succeeded' mas n√£o temos output ainda
                        if status == 'succeeded':
                            output = response_data.get('output', 'Sem sa√≠da dispon√≠vel')
                            return f"‚úÖ **Resposta do agente TESS ({agent_id}):**\n\n{output}"
                        
                        return f"‚è≥ Execu√ß√£o do agente em andamento. Status: {status}"
                    
                    return "‚è≥ Execu√ß√£o do agente iniciada. Aguarde o processamento."
                # Verificar se h√° full_response
                elif "full_response" in response and isinstance(response["full_response"], dict):
                    output = response["full_response"].get("output", "")
                    if output:
                        return f"‚úÖ **Resposta do agente TESS ({agent_id}):**\n\n{output}"
            
            # Se n√£o encontrou output em nenhum dos formatos esperados
            error_msg = response.get("error", "Erro desconhecido")
            error_details = response.get("details", {})
            
            # Verificar se temos detalhes espec√≠ficos do erro
            if isinstance(error_details, dict):
                if "status" in error_details and error_details["status"] == 422:
                    error_text = error_details.get("text", "")
                    try:
                        error_json = json.loads(error_text)
                        if "message" in error_json:
                            error_message = error_json["message"]
                            error_fields = error_json.get("errors", {})
                            
                            # Listar campos obrigat√≥rios faltantes
                            missing_fields = []
                            for field, msgs in error_fields.items():
                                if msgs and "required" in msgs[0]:
                                    missing_fields.append(field)
                            
                            if missing_fields:
                                return (f"‚ùå Erro 422: O agente '{agent_id}' exige campos obrigat√≥rios que n√£o foram fornecidos:\n"
                                       f"{', '.join(missing_fields)}\n"
                                       f"Por favor, forne√ßa esses campos ou use um agente diferente.")
                            
                            return f"‚ùå Erro ao executar agente: {error_message}"
                    except:
                        pass
                
                return (f"‚ùå Erro 422: O agente '{agent_id}' rejeitou a requisi√ß√£o, provavelmente "
                       f"porque faltam par√¢metros obrigat√≥rios ou o formato est√° incorreto.\n"
                       f"Tente usar um agente diferente ou verificar a documenta√ß√£o do agente.")
            
            return f"‚ùå Erro ao executar agente: {error_msg}"
        except Exception as e:
            logger.exception(f"Erro ao executar agente: {e}")
            return f"‚ùå Erro ao executar agente: {str(e)}"

    def _comando_listar_agentes_chat(self, params: Dict[str, Any]) -> str:
        """
        Lista apenas os agentes do tipo 'chat' dispon√≠veis na TESS
        
        Args:
            params: Par√¢metros (n√£o utilizados)
            
        Returns:
            Resposta formatada com os agentes de chat
        """
        # Chamar o m√©todo _comando_listar_todos_agentes com filtro de tipo 'chat'
        return self._comando_listar_todos_agentes({'tipo': 'chat'})

    def _comando_testar_api_listar_agentes_chat(self, params: Dict[str, Any]) -> str:
        """
        Testa a API do TESS para listar apenas os agentes do tipo 'chat'
        
        Args:
            params: Par√¢metros (n√£o utilizados)
            
        Returns:
            Resposta formatada com a lista de agentes de chat
        """
        # Chamar o m√©todo _comando_testar_api_listar_agentes com filtro de tipo 'chat'
        return self._comando_testar_api_listar_agentes({'tipo': 'chat'})

    def _comando_listar_agentes_por_keyword(self, params: Dict[str, Any]) -> str:
        """
        Lista agentes que cont√™m uma palavra-chave espec√≠fica no t√≠tulo ou descri√ß√£o
        
        Args:
            params: Par√¢metros com a keyword a ser usada na busca
            
        Returns:
            Resposta formatada com os agentes encontrados
        """
        keyword = params.get("keyword", "").strip()
        
        if not keyword:
            return "‚ùå Erro: Palavra-chave n√£o especificada. Por favor, forne√ßa uma palavra-chave para a busca."
        
        try:
            if TEST_API_TESS_AVAILABLE:
                logger.info(f"Realizando requisi√ß√£o para listar agentes TESS com palavra-chave: {keyword}")
                
                # Chama a fun√ß√£o listar_agentes com o par√¢metro keyword
                success, data = listar_agentes(is_cli=False)
                
                if success and 'data' in data:
                    agentes = data.get('data', [])
                    
                    # Filtrar localmente por cada palavra-chave
                    keywords = [k.strip().lower() for k in keyword.split() if k.strip()]
                    agentes_filtrados = []
                    
                    for agente in agentes:
                        title = agente.get('title', '').lower()
                        description = agente.get('description', '').lower()
                        slug = agente.get('slug', '').lower()
                        tipo = agente.get('type', '').lower()
                        
                        # Verificar se todas as palavras-chave est√£o presentes
                        if all(k in title or k in description or k in slug or k in tipo for k in keywords):
                            agentes_filtrados.append(agente)
                    
                    total = len(agentes_filtrados)
                    
                    if total > 0:
                        # Limitar para evitar respostas muito longas
                        max_display = 30
                        display_count = min(total, max_display)
                        
                        resposta = f"üìã Lista de agentes contendo '{keyword}' (Total: {total}):\n\n"
                        
                        for i, agent in enumerate(agentes_filtrados[:display_count], 1):
                            title = agent.get('title', 'Sem t√≠tulo')
                            id_num = agent.get('id', 'N/A')
                            slug = agent.get('slug', 'N/A')
                            tipo_agente = agent.get('type', 'N/A')
                            descricao = agent.get('description', 'Sem descri√ß√£o')
                            
                            # Adicionar emoji para agentes de chat para facilitar a identifica√ß√£o
                            emoji = "üí¨" if tipo_agente.lower() == "chat" else "üìù" if tipo_agente.lower() == "text" else "üîÑ"
                            
                            resposta += f"{i}. {title} {emoji}\n"
                            resposta += f"   ID: {id_num}\n"
                            resposta += f"   Slug: {slug}\n"
                            resposta += f"   Tipo: {tipo_agente.capitalize()}\n"
                            resposta += f"   Descri√ß√£o: {descricao}\n\n"
                        
                        if total > max_display:
                            resposta += f"... e mais {total - max_display} agentes n√£o exibidos.\n\n"
                        
                        resposta += "Para executar um agente, use: executar agente <slug> \"sua mensagem aqui\""
                        return resposta
                    else:
                        return f"‚ùå Nenhum agente encontrado com as palavras-chave '{keyword}'."
                else:
                    error_msg = data.get("error", "Erro desconhecido")
                    return f"‚ùå Erro ao listar agentes: {error_msg}"
            else:
                return "‚ùå Erro: M√≥dulo test_api_tess n√£o dispon√≠vel. N√£o √© poss√≠vel listar agentes."
        except Exception as e:
            logger.exception(f"Erro ao listar agentes por keyword: {e}")
            return f"‚ùå Erro ao listar agentes: {str(e)}"
    
    def _comando_listar_agentes_por_tipo_e_keyword(self, params: Dict[str, Any]) -> str:
        """
        Lista agentes de um tipo espec√≠fico que cont√™m uma palavra-chave no t√≠tulo ou descri√ß√£o
        
        Args:
            params: Par√¢metros com o tipo e a keyword para a busca
            
        Returns:
            Resposta formatada com os agentes encontrados
        """
        tipo = params.get("tipo", "").strip().lower()
        keyword = params.get("keyword", "").strip()
        
        if not tipo:
            return "‚ùå Erro: Tipo de agente n√£o especificado. Por favor, forne√ßa um tipo (chat, text, completion)."
        
        if not keyword:
            return "‚ùå Erro: Palavra-chave n√£o especificada. Por favor, forne√ßa uma palavra-chave para a busca."
        
        try:
            if TEST_API_TESS_AVAILABLE:
                logger.info(f"Realizando requisi√ß√£o para listar agentes TESS do tipo '{tipo}' com palavra-chave: {keyword}")
                
                # Chama a fun√ß√£o listar_agentes com os par√¢metros filter_type
                success, data = listar_agentes(is_cli=False, filter_type=tipo)
                
                if success and 'data' in data:
                    agentes = data.get('data', [])
                    
                    # Filtrar localmente por cada palavra-chave
                    keywords = [k.strip().lower() for k in keyword.split() if k.strip()]
                    agentes_filtrados = []
                    
                    for agente in agentes:
                        title = agente.get('title', '').lower()
                        description = agente.get('description', '').lower()
                        slug = agente.get('slug', '').lower()
                        
                        # Verificar se todas as palavras-chave est√£o presentes
                        if all(k in title or k in description or k in slug for k in keywords):
                            agentes_filtrados.append(agente)
                    
                    total = len(agentes_filtrados)
                    
                    if total > 0:
                        # Limitar para evitar respostas muito longas
                        max_display = 30
                        display_count = min(total, max_display)
                        
                        resposta = f"üìã Lista de agentes do tipo '{tipo}' contendo '{keyword}' (Total: {total}):\n\n"
                        
                        for i, agent in enumerate(agentes_filtrados[:display_count], 1):
                            title = agent.get('title', 'Sem t√≠tulo')
                            id_num = agent.get('id', 'N/A')
                            slug = agent.get('slug', 'N/A')
                            tipo_agente = agent.get('type', 'N/A')
                            descricao = agent.get('description', 'Sem descri√ß√£o')
                            
                            # Adicionar emoji para agentes de chat para facilitar a identifica√ß√£o
                            emoji = "üí¨" if tipo_agente.lower() == "chat" else "üìù" if tipo_agente.lower() == "text" else "üîÑ"
                            
                            resposta += f"{i}. {title} {emoji}\n"
                            resposta += f"   ID: {id_num}\n"
                            resposta += f"   Slug: {slug}\n"
                            resposta += f"   Tipo: {tipo_agente.capitalize()}\n"
                            resposta += f"   Descri√ß√£o: {descricao}\n\n"
                        
                        if total > max_display:
                            resposta += f"... e mais {total - max_display} agentes n√£o exibidos.\n\n"
                        
                        resposta += "Para executar um agente, use: executar agente <slug> \"sua mensagem aqui\""
                        return resposta
                    else:
                        return f"‚ùå Nenhum agente do tipo '{tipo}' encontrado com as palavras-chave '{keyword}'."
                else:
                    error_msg = data.get("error", "Erro desconhecido")
                    return f"‚ùå Erro ao listar agentes: {error_msg}"
            else:
                return "‚ùå Erro: M√≥dulo test_api_tess n√£o dispon√≠vel. N√£o √© poss√≠vel listar agentes."
        except Exception as e:
            logger.exception(f"Erro ao listar agentes por tipo e keyword: {e}")
            return f"‚ùå Erro ao listar agentes: {str(e)}" 